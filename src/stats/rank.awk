BEGIN {
	FS = "\t"
	OFS = "\t"

	# Αν έχει καθοριστεί μέγιστο πλήθος διανομών βαθμολογίας ανά παίκτη,
	# τότε θα κάνουμε κάποια στιγμή αναγωγή του πλήθους αυτού σε 1000
	# προκειμένου να υπολογίσουμε το βάρος της κάθε παρτίδας, καθώς ο
	# τύπος υπολογισμού των βαρών βασίστηκε σε μοντέλο 1000 διανομών.

	if (ikanes)
	scale = 1000 / ikanes
}

# Πρώτα διαβάζουμε τυχόν αρχείο ποινών. Το αρχείο είναι ταξινομημένο κατά
# κωδικό παρτίδας και έχει την εξής μορφή:
#
#	Κωδικός παρτίδας
#	Login name παίκτη
#	Φυτευτά καπίκια ανά διανομή
#
# Για κάθε παρτίδα με κωδικό μικρότερο από τον κωδικό της τελευταία ποινής
# του παίκτη, αγνοούνται τα πραγματικά καπίκια που κέρδισε ή έχασε ο παίκτης
# και λογίζονται αυτά που αναφέρονται στο ποινολόγιο. Αν τα καπίκια ποινής
# είναι μηδέν, τότε δίνεται αμνηστία στον παίκτη και τυχόν προηγούμενες ποινές
# διαγράφονται.

NF == 3 {
	$1 += 0		# κωδικός παρτίδας
	$3 += 0		# φυτευτά καπίκια/διανομή

	if ($3) {
		pini_partida[$2] = $1
		pini_kapikia[$2] = $3
	}

	else {
		delete pini_partida[$2]
		delete pini_kapikia[$2]
	}

	next
}

# Διαβάζουμε δεδομένα παρτίδων από αρχεία της μορφής:
#
#	Κωδικός παρτίδας
#	Πλήθος παιγμένων διανομών
#	Login name παίκτη
#	Συνολικά καπίκια που κέρδισε ή έχασε ο παίκτης

NF == 4 {
	$1 += 0
	$2 += 0
	$4 += 0

	pektis = $3

	# Αν υπάρχει ποινή για τον παίκτη, τότε αυτή περιλαμβάνει δύο στοιχεία:
	# Πρώτο στοιχείο είναι ο κωδικός παρτίδας από τον οποίον και πίσω τα
	# καπίκια ανά διανομή λογίζονται φυτευτά (array "pini_partida"), και
	# δεύτερο στοιχείο είναι τα φυτευτά καπίκια ανά διανομή (array "pini_kapikia").
	# Λαμβάνεται υπόψη μόνο η τελευταία ποινή.

	if ((pektis in pini_partida) && ($1 <= pini_partida[pektis]) && (($2 * pini_kapikia[pektis]) < $4))
	$4 = $2 * pini_kapikia[pektis]

	# Αν δεν έχει καθοριστεί μέγιστο πλήθος διανομών βαθμολογίας, τότε
	# όλες οι διανομές λαμβάνονται ισότιμα υπ' όψιν και ο «βαθμός»
	# θα προκύψει ως πηλίκο καπικιών προς πλήθος παιγμένων διανομών.

	if (!ikanes) {
		dianomes[pektis] += $2
		kapikia[pektis] += $4
		next
	}

	# Έχει καθοριστεί μέγιστο πλήθος διανομών βαθμολογίας, οπότε πρέπει
	# να δούμε αν έχουμε ήδη συμπεριλάβει τις απαιτούμενες διανομές για
	# τον ανά χείρας παίκτη. Αν έχουμε ήδη συμπεριλάβει τις απαιτούμενες
	# διανομές για τον ανά χείρας παίκτη, τότε απλώς αγνοούμε την ανά
	# χείρας παρτίδα για τον ανά χείρας παίκτη.

	if ((dianomes[pektis] += 0) > ikanes)
	next

	# Κάνουμε αναγωγή του τρέχοντος πλήθους παιγμένων διανομών τού ανά
	# χείρας παίκτη, σε φάσμα 1000 διανομών. Εκεί, δηλαδή στις 1000
	# διανομές, ο τύπος που δίνει τα βάρη είναι e^(-((x/666)^4)) όπου
	# x είναι το πλήθος των παιγμένων διανομών.

	varos = (dianomes[pektis] * scale) / 666
	varos = varos * varos * varos * varos
	varos = exp(-varos)

	# Προσαυξάνουμε ή μειώνουμε το σύνολο καπικιών του ανά χείρας παίκτη
	# με τα συνολικά καπίκια που κέρδισε ή έχασε ο παίκτης στην ανά χείρας
	# παρτίδα, αλλά μειώνουμε τη βαρύτητα των καπικιών αυτών ανάλογα με
	# το πλήθος των διανομών που έχουμε ήδη συμπεριλάβει. Όσο πιο «μακρυνή»
	# η παρτίδα στο χρόνο, τόσο μικρότερη βαρύτητα έχουν τα καπίκια που
	# κέρδισε ή έχασε ο παίκτης.

	kapikia[pektis] += ($4 * varos)

	# Αυξάνουμε το πλήθος παιγμένων διανομών του ανά χείρας παίκτη κατά
	# το πλήθος των παιγμένων διανομών της ανά χείρας παρτίδας.

	dianomes[pektis] += $2
	next
}

# Αν θέλουμε μπορούμε να διαβάζουμε και την τρέχουσα βαθμολογία από αρχεία
# της μορφής:
#
#	Login name παίκτη
#	Βαθμολογία παίκτη
#
# Τα στοιχεία αυτά προκύπτουν από την παράμετρο "ΒΑΘΜΟΛΟΓΙΑ" του κάθε
# παίκτη και πρόκειται για string της μορφής: "βαθμός#διανομές", όπου
# "βαθμός" είναι ένας δεκαδικός αριθμός που απεικονίζει τον μέσο όρο
# καπικιών που κερδίζει ή χάνει ο παίκτης σε κάθε παιγμένη διανομή,
# π.χ. "2.21#1023" σημαίνει ότι ο παίκτης κερδίζει περίπου 2.21 καπίκια
# σε κάθε παιγμένη διανομή, "-0.92#1005" σημαίνει ότι ο παίκτης χάνει
# περίπου 0.92 καπίκια σε κάθε παιγμένη διανομή κοκ.

NF == 2 {
	pektis = $1
	rank_old[pektis] = $2
	next
}

# Εκτυπώνουμε δεδομένα βαθμολογίας. Εφόσον έχουμε διαβάσει τα τρέχοντα
# δεδομένα βαθμολογίας, εκτυπώνονται μόνον οι βαθμολογίες που έχουν αλλάξει,
# αλλιώς εκτυπώνονται όλες οι βαθμολογίες.

END {
	for (pektis in dianomes) {
		dianomes[pektis] += 0
		kapikia[pektis] += 0

		if (dianomes[pektis] <= 0) {
			prank = "0.00"
			rank_new = ""
		}

		else {
			prank = sprintf("%.2f", kapikia[pektis] / ikanes)
			rank_new = sprintf("%.2f#%d", prank, dianomes[pektis])
		}

		if (rank_new == rank_old[pektis])
		continue

		if (logfile)
		print pektis ": " (rank_new ? rank_new : "delete") >logfile

		# Αν το πρόγραμμα «τρέχει» σε update mode, εκτυπώνουμε sql scripts
		# που θα εκτελεστούν αργότερα από τον sql.

		if (update) {
			if (rank_new)
			print "REPLACE INTO `peparam` (`pektis`, `param`, `timi`) " \
				"VALUES ('" pektis "', 'ΒΑΘΜΟΛΟΓΙΑ', '" rank_new "')\n;"

			else
			print "DELETE FROM `peparam` WHERE (`pektis` LIKE '" pektis "') " \
				"AND (`param` LIKE 'ΒΑΘΜΟΛΟΓΙΑ')\n;"
		}

		# Αλλιώς εκτυπώνουμε τη βαθμολογία για τους παίκτες που έχουν αλλαγή.

		else if (rank_new)
		print pektis, prank, dianomes[pektis] | "sort  -k2rn -k3rn -k1"
	}
}
